[StructuredProductsDealPackage]FObject:udmcTRFAsianPayoff
# ------------------------------------------
# PAYOFF EXPRESSION
# Target Redemption Forward, Asian
#
# ------------------------------------------

# PARAMETERS
param double targetValue;
param int adjustStrike;
param matrix(double) notional1;
param matrix(double) notional2;
param double strike;
param double accumulatedValue;
param int isCallOption;
param matrix(double) timeSteps;
param matrix(double) isAveragePrice;
param matrix(double) isCustomTimeStep;
param double averagePeriodTotal;
param double averagePeriodItems;
param double averageFixedToday;

# PROCESS
process matrix(double) S;

# LOCAL VARIABLES
double callOrPut = 2.0 * isCallOption - 1.0;
double accumulated = accumulatedValue;
double intrinsicValue = 0.0;
double adjustedStrike = 0.0;
int tMax = length(timeSteps);
int t = 0;
int terminationEvent = 0;
double settlementValue = 0.0;
double previousAccumulated = accumulatedValue;
double accumulatedVsTarget = 0.0;
double zeroComparison = 0.00000001;
double currentPeriodTotal = averagePeriodTotal;
double currentAverage = 0.0;
double daysInPeriod = averagePeriodItems;
int periodNumber = 0;

# MAIN LOOP
terminationEvent = 0;
accumulated = accumulatedValue;
currentPeriodTotal = averagePeriodTotal;
currentAverage = 0.0;
daysInPeriod = averagePeriodItems;
periodNumber = -1;

for t = 0 to tMax
{
    if (not terminationEvent)
    {
        if (t == 0 and averageFixedToday > 0.0)
        {
            daysInPeriod = 0.0;
            currentPeriodTotal = 0.0;
        }
        else
        {
            daysInPeriod = daysInPeriod + 1.0;
            currentPeriodTotal = currentPeriodTotal + (S[t]);
        };
        if (isCustomTimeStep[t] > 0.0)
        {
            currentAverage = currentPeriodTotal / daysInPeriod;
            currentPeriodTotal = 0.0;
            daysInPeriod = 0.0;
            periodNumber = periodNumber + 1;
    
            previousAccumulated = accumulated;
            intrinsicValue = (currentAverage - (strike)) * callOrPut;

            if (intrinsicValue  > 0.0)
            {
            # The ITM side, which is where we compare to the Target Level.
                accumulated = accumulated + intrinsicValue;
                adjustedStrike = currentAverage - (targetValue - previousAccumulated) * callOrPut;

                accumulatedVsTarget = targetValue - accumulated;
                if (accumulatedVsTarget < zeroComparison)
                {
                    terminationEvent = 1;
                    if(adjustStrike)
                    {
                        intrinsicValue = (currentAverage - adjustedStrike) * callOrPut;
                    };
                };
                settlementValue = notional1[periodNumber] * intrinsicValue;
             }
             else
             {
             # The OTM side, which is where we check against a potential barrier
                 settlementValue = notional2[periodNumber] * intrinsicValue;
             };
                
             #CASHFLOW
             cashFlow(periodNumber, settlementValue);
        };
    };
};        

...
