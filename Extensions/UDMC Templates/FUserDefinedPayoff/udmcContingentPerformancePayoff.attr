[UDMC Templates]FObject:udmcContingentPerformancePayoff
#--------------------------------------------
# PAYOFF EXPRESSION
# Payoff for a contingent option with an up and out barrier and payoff relative to start
#
# INTERPRETATION
# A performance call option which pays out if the upper outside barrier is not knocked
#
# DEFINITION
# nAssets: Number of underlying assets in the basket.
# barrierType: The type of barrier option (set on the Exotic/Barrier tab).
# strike: The strike of the payoff.
# barriers: The barrier values, Barrier price events for barrier instruments.
# weights: The weights of the underlying basket components. 0 if barrier instrument, 1 if payoff instrument.
#--------------------------------------------

#PARAMETERS
param int isCall;
param int nAsset;
param int barrierType;
param int barrierIsCrossed;
param double strike;
param matrix(double) barriers;
param matrix(double) weights;

#PROCESS 
process matrix(double) S;

#LOCAL VARIABLES
double callOrPut = (2.0 * isCall) - 1.0;
double optionValue = 0.0;
matrix(double) isContingency = (weights == 0.0);
int isKnockIn = (barrierType == 2) or (barrierType == 4);
int isDownBarrier = (barrierType == 1) or (barrierType ==2);
int payOffIndex = indexMin(isContingency);
int isKnocked = 0;
int i = 0;

#MAIN LOOP
isKnocked = 0;
for i = 0 to nAsset
{    
    if (isContingency[i] == 1.0)
    {
        if ((barrierType > 0) and (barrierIsCrossed == 0))
        {
            if (isDownBarrier == 1)
            {
                isKnocked = isKnocked or (min(S[i,:]) < barriers[i]);
            }
            else # Upper barrier
            {
                isKnocked = isKnocked or (max(S[i,:]) > barriers[i]);
            };
        }
        else
        {
            isKnocked = isKnocked or barrierIsCrossed;
        };
    };
}; 

if ((barrierType == 0) or (isKnockIn == isKnocked))
{
    optionValue = max(callOrPut * (S[payOffIndex, -1] / S[payOffIndex, 0] - strike), 0.0);
}
else
{
    optionValue = 0.0;
};

#CASHFLOW
cashFlow(0, optionValue);

...
