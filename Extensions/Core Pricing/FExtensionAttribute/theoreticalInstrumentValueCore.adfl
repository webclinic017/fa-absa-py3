[Core Pricing]FCashFlowInstrument:theoreticalInstrumentValueCore = select(isGenericCouponOrSpreadQuoted or isFxOutrightRateQuoted, 
  true->collapse(theoreticalSpotValueFromTheoreticalPrice), 
  false->select(splitValuationInCashFlowPart, 
    false->select(valuationModelName, 
      "Cash Flow"->collapse(theoreticalLegComponentsValueSimple), 
      default->collapse(theoreticalModelValue)), 
    true->theoreticalInstrumentComponentValue + theoreticalLegComponentsValue));
[Core Pricing]FCfd:theoreticalInstrumentValueCore = setDateTimePart(theoreticalModelValue, instrumentSpotDate);
[Core Pricing]FCombination:theoreticalInstrumentValueCore = select(hasMappedPriceCurve, 
  true->collapse(theoreticalModelValue), 
  default->shunt[priceSource, doSplitAll](isCalculatedTheoretically, 
    true->collapse(theoreticalInstrumentValueCombinationAsSumOfConstituents), 
    false->timeDistributionFactor * marketSpotValue));
[Core Pricing]FCurrency:theoreticalInstrumentValueCore = marketSpotValue;
[Core Pricing]FDepositaryReceipt:theoreticalInstrumentValueCore = underlying:forwardValue [priceSource, doSplitAll, forwardValueDate = instrumentSpotDate, calculationCurrency] * conversionRatio;
[Core Pricing]FETF:theoreticalInstrumentValueCore = shunt[priceSource, doSplitAll](isCustomValued, 
  true->collapse(theoreticalModelValue), 
  false->shunt[priceSource, doSplitAll](priceNeedsDividendAdjustment, 
    true->(underlying:discountCurve).DiscountValue(timeShiftDividendAdjustedPrice(underlying :* "timeShiftDividendAdjustedPrice(theoreticalOrMarketInstrumentValueInCalculationCurrency, dividendForecast, adsPriceDate, -dividendFactor) * timeDistributionFactor" [priceSource, doSplitAll], dividendForecast, adsPriceDate, dividendFactor), instrumentSpotDate) * fxUnderlyingToInstrument, 
    default->(underlying:discountCurve).DiscountValue(underlying :* "theoreticalOrMarketInstrumentValueInCalculationCurrency * timeDistributionFactor" [priceSource, doSplitAll], instrumentSpotDate) * fxUnderlyingToInstrument));
[Core Pricing]FFund:theoreticalInstrumentValueCore = setDateTimePart(portfolioInstrumentAndTrades :* "theoreticalEqualsMarketNAVPerUnit" [displayCurrency := currency], instrumentSpotDate);
[Core Pricing]FFuture:theoreticalInstrumentValueCore = select(isReciprocal and normalizeFxRisk, 
  true->theoreticalModelValue * priceGreekRiskFactorReciprocalFxAdjustmentValue, 
  false->select(isQuanto and valuationModelNeedsFxConversion, 
    true->theoreticalModelValue * fxStrikeToInstrument, 
    false->collapse(theoreticalModelValue)));
[Core Pricing]FFxRate:theoreticalInstrumentValueCore = select(isReciprocal, 
  true->normalFxRate:invertedMarketSpotValue [priceSource], 
  false->marketSpotValue);
[Core Pricing]FInstrument:theoreticalInstrumentValueCore = select(isCalculatedTheoretically, 
  true->select(isBuySellbackRepoRateQuoted, 
    true->collapse(theoreticalSpotValueFromTheoreticalPrice), 
    false->collapse(theoreticalModelValue)), 
  false->marketSpotValue);
[Core Pricing]FOdf:theoreticalInstrumentValueCore = select(isReciprocal and normalizeFxRisk, 
  true->theoreticalModelValue * priceGreekRiskFactorReciprocalFxAdjustmentValue, 
  false->collapse(theoreticalModelValue));
[Core Pricing]FOption:theoreticalInstrumentValueCore = select(isFxAdjusted, 
  true->select(valuationModelNeedsFxConversion, 
    true->theoreticalModelValue * fxStrikeToInstrument, 
    false->collapse(theoreticalModelValue)), 
  false->collapse(theoreticalModelValue));
[Core Pricing]FVolatilityFuture:theoreticalInstrumentValueCore = select(valuationModelNeedsFxConversion, 
  true->theoreticalModelValue * fxStrikeToInstrument, 
  default->collapse(theoreticalModelValue));