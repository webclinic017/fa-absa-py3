
"""-------------------------------------------------------------------------------------------------------
MODULE
    AUTO GENERATED By Prime Broker Column Creator
    
    Rename this script by removing "_template" from name.
    
    (c) Copyright 2010 by Sungard FRONT ARENA. All rights reserved.

DESCRIPTION

-------------------------------------------------------------------------------------------------------"""
import acm
import re
import csv
import cStringIO
from math import *
import FAptTest
import FAptLauncher
import FAptReportUtils
import FAptReportCommon
from FAptIdRecon import FAptIdRecon

import FLogger

logger = FLogger.FLogger.GetLogger('APT')

TERM_MAP_IRF =  {
        '1d' : 'ONE_DAY',
        '30d': 'ONE_MONTH',
        '1m' : 'ONE_MONTH',
        '3m' : 'THREE_MONTH',
        '6m' : 'SIX_MONTH',
        '12m': 'ONE_YEAR',
        '1y' : 'ONE_YEAR',
        }
                
RATING_MAP = {
        'Aaa' : 'AAA',
        'Aa1' : 'AA+',
        'Aa2' : 'AA',
        'Aa3' : 'AA-',
        'A1'  : 'A+',
        'A2'  : 'A',
        'A3'  : 'A-',
        'Baa1': 'BBB+',
        'Baa2': 'BBB',
        'Baa3': 'BBB-',
        'Ba1' : 'BB+',
        'Ba2' : 'BB',
        'Ba3' : 'BB-',
        'B1'  : 'B+',
        'B2'  : 'B',
        'B3'  : 'B-',
        'Caa1': 'CCC+',
        'Caa2': 'CCC',
        'Caa3': 'CCC-',
        'Ca'  : 'CC',
        'C1'  : 'D',
        'C'   : 'CC'
        }


class BorrowerClassDict(dict):
    def __getitem__(self, item):
        try:
            return dict.__getitem__(self, item)
        except KeyError:
            value = self[item] = type(self)()
            return value

borrower_class_dict = BorrowerClassDict()
borrower_class_source = FAptReportUtils.FAptReportParameters().get('BORROWER_CLASS_SOURCE')
context = acm.GetDefaultContext()
txt = context.GetExtension("FStringResource", "FObject", borrower_class_source).Value()
if txt:
    reader = csv.reader(cStringIO.StringIO(txt),delimiter='\t')
    for row in reader:
        if not row: 
            continue
        else: 
            borrower_class_add_info_specs = row
            break
    for row in reader:
        borrower_class_dict[row[0]][row[1]][row[2]] = row[3]
    

global total_market_value
global composition_currency

def get_underlying(ins):
    try:
        if ins.IsFutureOnNotional():
            if ins.IsAUDF(): return ins.Underlying()
            return ins.Underlying().SelectedDeliverable()
        return ins.ValuationUnderlying()
    except AttributeError:
        return ins.ValuationUnderlying()

def acmClass(object):
    return object.Class().StringKey()
    
def frequencyMapping(period):
    res = acm.Time.DatePeriodsInYear(period)
    if res > 12:
        return 12
    elif res < 1:
        return 1
    return res
    
def paymentFrequencyCDS(cds):
    try:
        creditDefaultLeg = [
            leg for leg in cds.Legs() if leg.LegType() == 'Credit Default'
            ][0]
        return frequencyMapping(creditDefaultLeg.RollingPeriod())
    except (IndexError, KeyError):
        return
    
def payFrequencyIRS(irs):
    try:
        payLeg = [leg for leg in irs.Legs() if leg.PayLeg()][0]
        return frequencyMapping(payLeg.RollingPeriod())
    except (IndexError, RuntimeError):
        return
        
def receiveFrequencyIRS(irs):
    try:
        recLeg = [leg for leg in irs.Legs() if not leg.PayLeg()][0]
        return frequencyMapping(recLeg.RollingPeriod())
    except (IndexError, RuntimeError):
        return
        
def apt_ins_id(ins):
    ins_type = ins.InsType()
    if ins_type in ('Deposit'): 
        ins_type = 'Curr'
        ins = ins.Currency()
    if ins_type in FAptIdRecon.RECON_INS_TYPES:
        id_type = apt_id_type(ins)
        if id_type == "ISIN" and ins_type not in ('Curr'): return ins.Isin()
        elif id_type == "ISIN" and ins_type in ('Curr'): return ins.Name()
        elif id_type == "INTERNAL":
            if ins_type in ('Fx Rate'): return ins.ForeignCurrency()
            else: return ins.Name()
        elif id_type in ("DATASTREAM", "SEDOL"):
            id = ins.Alias(id_type)
            if not id:
                return "ID MISSING"
            return id
        else: 
            try:
                id = ins.add_info(id_type)
                return id if id else "ID MISSING"
            except:
                return "ID MISSING"
    return ins.Name() if ins_type not in ('Fx Rate') else ins.ForeignCurrency()

def apt_id_type_hierarchy():
    return [type.Name() for type in acm.FChoiceList.Select01('name = "APT Recon Id Type" and list = "MASTER"', '').Choices().SortByProperty("SortOrder")]

    
def apt_id_type(ins):
    id_type_hierarchy = apt_id_type_hierarchy()
    ins_type = ins.InsType()
    if ins.InsType() in ('Deposit'):
        ins_type = 'Curr'
        ins = ins.Currency()
    elif ins.InsType() in ('Fx Rate'):
        return "ISIN"
    if ins_type in FAptIdRecon.RECON_INS_TYPES:
        if ins_type in ('Curr'):
            if ins.Alias('DATASTREAM'):
                return "DATASTREAM"
            return "ISIN"
        apt_id = None
        id_type = ins.AdditionalInfo().APT_Recon_Id_Type()
        if id_type:
            return id_type if id_type not in ('OTC') else 'INTERNAL'
        for i in range(len(id_type_hierarchy)-1):
            id_type = id_type_hierarchy[i]
            try:
                if id_type == "ISIN": apt_id = ins.Isin()
                elif id_type in ('DATASTREAM', 'SEDOL'):
                    apt_id = ins.Alias(id_type)
                else: apt_id = ins.add_info(id_type) 
            except:
                pass
            if apt_id:
                return id_type
        return 'INTERNAL'
    return 'INTERNAL'


        
def apt_asset_class(ins):
    if acmClass(ins) == 'FFuture':
        if ins.PayType() == 'Forward': return 'FORWARD'
        else:
            und_type = ins.Underlying().InsType()
            return 'FUTURE'
    elif acmClass(ins) == 'FOption':
        und = ins.Underlying()
        if acmClass(und) == 'FSwap': return 'SWAPTION'
        return 'OPTION'
    elif acmClass(ins) == 'FSwap': return 'IRS'
    elif acmClass(ins) == 'FIndexLinkedSwap': return 'InflationSwap'
    elif acmClass(ins) == 'FCreditDefaultSwap': return 'CDS'
    elif acmClass(ins) in ('FCfd', 'FTotalReturnSwap'): return 'CFD'
    elif acmClass(ins) == 'FBond': return 'BOND'
    elif acmClass(ins) == 'FBill': return 'BOND'
    elif acmClass(ins) == 'FFrn': return 'FRN'
    elif acmClass(ins) == 'FCap': return 'CAP'
    elif acmClass(ins) == 'FFloor': return 'FLOOR'
    elif acmClass(ins) == 'FAssetMortgageBackedSecurity': return 'MBS'
    elif acmClass(ins) in ('FStock', 'FEquityIndex'): return 'EQUITY'
    elif acmClass(ins) in ('FCurrency'): return 'CURRENCY'
    elif acmClass(ins) == 'FConvertible': return 'CONVERTIBLE'
    elif acmClass(ins) == 'FCommodity': return 'COMMODITY'
    

def APT_Compositions_01_CompositionCurrency(rowObject):
    """Autogenerated for portfoliosheet. """
    return rowObject.Name()

def APT_Compositions_02_Date(rowObject):
    """Autogenerated for portfoliosheet. """
    return acm.Time.DateValueDay()
    
def APT_Compositions_03_IdType(rowObject):
    """Autogenerated for portfoliosheet. """
    if acmClass(rowObject) == 'FSingleInstrumentAndTrades':
        ins = rowObject.Instrument()
        return apt_id_type(ins)
    return "INTERNAL"

    
def APT_Compositions_04_Id(rowObject):
    if acmClass(rowObject) == 'FMultiInstrumentAndTrades': 
        return '/'+rowObject.StringKey()
    elif acmClass(rowObject) == 'FPortfolioInstrumentAndTrades':
        return rowObject.Portfolio().Name()
    elif acmClass(rowObject) == 'FSingleInstrumentAndTrades':
        ins = rowObject.Instrument()
        return apt_ins_id(ins)


def APT_Compositions_05_Units(units):
    try:
        return float(units.Number())
    except:
        return 0
        
def APT_Compositions_06_Price(price):
    try:
        return float(price.Number())
    except:
        return 0
        
def APT_Compositions_08_DomesticCurrency(ins):
    curr = ins.DomesticCurrency()
    datastream = curr.Alias('DATASTREAM')
    return datastream if datastream else curr
    
def APT_Compositions_07_ForeignCurrency(ins):
    curr = ins.ForeignCurrency()
    datastream = curr.Alias('DATASTREAM')
    return datastream if datastream else curr

def APT_Compositions_10_ForeignCurrencyPrice(price_array):
    price = price_array.DoubleAt(0)
    return price if price else 0

def APT_Compositions_11_DomesticCurrencyPrice(price_array):
    price = price_array.DoubleAt(1)
    return price if price else 0

def APT_Compositions_12_ForeignCurrencyUnits(units_array):
    units = units_array.DoubleAt(0)
    return units if units else 0


def APT_Compositions_13_DomesticCurrencyUnits(units_array):
    units = units_array.DoubleAt(1)
    return units if units else 0
        
def APT_Compositions_14_BaseCurrencyPrice(price_array):
    try:
        price = price_array.DoubleAt(2)
    except:
        price = 0
    return price if price else 0


def APT_Compositions_15_BaseCurrencyUnits(units_array):
    try:
        units = units_array.DoubleAt(2)
    except:
        units = 0
    return units if units else 0

def APT_Compositions_16_CfdCurrencyValues(rowObject):
    return ';'.join([str(i.Number()) for i in rowObject])
    

def APT_Compositions_17_CfdUnderlyingValues(rowObject):
    return ';'.join([str(i.Number()) for i in rowObject])

def APT_Compositions_18_CfdPaymentsCurrency(rowObject):
    return ';'.join([str(i.Name()) for i in rowObject])



def APT_Universe_01_AssetClass(ins):
    """Autogenerated for portfoliosheet. """
    return apt_asset_class(ins)

def APT_Universe_02_Id(ins):
    """Autogenerated for portfoliosheet. """
    return apt_ins_id(ins)

def APT_Universe_03_IdType(ins):
    """Autogenerated for portfoliosheet. """
    return apt_id_type(ins)
      
def APT_Universe_04_MarketDataDate(rowObject):
    """Autogenerated for portfoliosheet. """
    return acm.Time.DateValueDay()

def APT_Universe_06_UnderlyingIdType(ins):
    """Autogenerated for portfoliosheet. """
    try:
        und = get_underlying(ins)
        return apt_id_type(und)
    except AttributeError:
        return
    
def APT_Universe_07_UnderlyingId(ins):
    und = get_underlying(ins)
    try:
        return apt_ins_id(und)
    except AttributeError:
        return
        
        
def APT_Universe_08_Price(price):
    return price.Number() if price else 0

def APT_Universe_09_InitialPrice(averagePrice):
    """Autogenerated for portfoliosheet. """
    return averagePrice.Number() if averagePrice else 0
 
def APT_Universe_10_ForwardPrice(averagePrice):
    """Autogenerated for portfoliosheet. """
    return averagePrice.Number() if averagePrice else 0
    
def APT_Universe_11_UnderlyingPrice(undPrice):
    return undPrice.Number() if undPrice else None

def APT_Universe_12_Strike(strikeValueModel):
    """Autogenerated for portfoliosheet. """
    return strikeValueModel.Number() if strikeValueModel else None

def APT_Universe_13_Type(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FOption':
        if ins.OptionTypeIsCall(): return 'CALL'
        return 'PUT'

def APT_Universe_14_ExerciseType(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FOption':
        exeType = ins.ExerciseType()
        if  exeType == 'European': return 'EUROPEAN'
        elif exeType == 'American': return 'AMERICAN'

def APT_Universe_15_Delta(priceDeltaInstrument):
    """Autogenerated for portfoliosheet. """
    return priceDeltaInstrument.Number() if priceDeltaInstrument else None

def APT_Universe_16_DividendYield(rowObject):
    """Autogenerated for portfoliosheet. """
    return

def APT_Universe_17_RiskFreeRate(rowObject):
    """Autogenerated for portfoliosheet. """
    return

def APT_Universe_18_Issuer(ins):
    """Autogenerated for portfoliosheet. """
    und = get_underlying(ins)
    credit_ref = und if und else ins
    issuer = credit_ref.Issuer().Name() if credit_ref.Issuer() else 'None'
    return issuer
    
def get_borrower_class_attr(credit_ref, index):
    try:
        return getattr(credit_ref.AdditionalInfo(),borrower_class_add_info_specs[index])()
    except AttributeError:
        logger.info('Additional Info Specification %s not found', borrower_class_add_info_specs[index])
        return None
    
def get_borrower_class_from_dict(credit_ref):
    #global borrower_class_add_info_specs
    #global borrower_class_dict
    if borrower_class_add_info_specs:
        sector = get_borrower_class_attr(credit_ref, 0)
        group = get_borrower_class_attr(credit_ref, 1)
        sub_group = get_borrower_class_attr(credit_ref, 2)
        if not sector and not group and not sub_group:
            return 'Manufacturing'
        borrower_class = borrower_class_dict[sector][group][sub_group]
        if borrower_class: 
            return borrower_class
        borrower_class = borrower_class_dict[sector][group]['']
        if borrower_class:
            return borrower_class
        borrower_class = borrower_class_dict[sector]['']['']
        if borrower_class:
            return borrower_class
        return None

def APT_Universe_19_BorrowerClass(ins, creditReferenceIssuer):
    """Autogenerated for portfoliosheet. """
    credit_ref = ins.CreditReferenceOrSelf()
    if ins.InsType() in ('Cap', 'Floor'):
        return 'Swap'
    elif credit_ref.InsType() in ('Bond', 'Convertible', 'FRN', 'Bill', 'MBS/ABS', 'FreeDefCF'):
        issuer = credit_ref.Issuer()
        party_choice_list = acm.FChoiceList.Select01('name = "Party Choice Lists" and list = "MASTER"', '')
        apt_borrower_class_index = party_choice_list.Choices().SortByProperty('SortOrder').FindString('APT Borrower Classification')
        if issuer:
            borrower_class = getattr(issuer, 'Free'+str(apt_borrower_class_index+1)+'ChoiceList')()
            if borrower_class:
                return borrower_class
        borrower_class = get_borrower_class_from_dict(credit_ref)
        return borrower_class if borrower_class else 'Manufacturing'
 
    
def APT_Universe_20_CreditRating(ins):
    instype = ins.InsType()
    if instype in ('Cap', 'Floor'):
        return 'AAA'
    elif instype in ('Bond', 'Convertible', 'FRN', 'CreditDefaultSwap', 'Bill', 'MBS/ABS', 'FreeDefCF'):
        ins = ins.CreditReferenceOrSelf()
        ratings_choice_list = acm.FChoiceList.Select01('name = "Ratings" and list = "MASTER"', '')
        context = acm.GetDefaultContext()
        rating_name = context.GetExtension('FParameters', 'FObject', 'FAptReportParameters').Value().At('CREDIT_RATING')
        rating_index = ratings_choice_list.Choices().SortByProperty('SortOrder').FindString(rating_name)
        rating = getattr(ins, 'Rating'+str(rating_index+1)+'ChlItem')()
        try:
            ratingName = rating.Name()
            for value in RATING_MAP.itervalues():
                if value == ratingName:
                    return ratingName
            return RATING_MAP[ratingName]
        except (AttributeError, KeyError):
            logger.info('No valid S&P rating found for instrument %s. Setting default rating to %s', ins.Name(), 'BBB')
            return 'BBB'
    
def APT_Universe_21_IssueDate(ins):
    """Autogenerated for portfoliosheet. """
    return ins.StartDate()

def APT_Universe_22_RedemptionDate(ins):
    """Autogenerated for portfoliosheet. """
    try:
        return ins.EndDate()
    except AttributeError:
        return None

def APT_Universe_23_Maturity(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FCreditDefaultSwap':
        return ins.EndDate()

def APT_Universe_24_Expires(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) in ('FOption', 'FFuture', 'FSwap', 'FCurrencySwap'):
        return acm.Time.AsDate(ins.ExpiryDate())
    elif acmClass(ins) in ('FRepo'):
        return ins.EndDate()

def APT_Universe_25_CouponFrequency(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) in ('FBond', 'FFrn', 'FConvertible', 'FBill', 'FAssetMortgageBackedSecurity', 'FFreeDefinedCashFlow'):
        try:
            return frequencyMapping(ins.Legs().First().RollingPeriod())
        except RuntimeError:
            return 0
    return

def APT_Universe_26_PaymentFrequency(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FCreditDefaultSwap':
        return paymentFrequencyCDS(ins)
    elif acmClass(ins) in ('FSwap', 'FFrn', 'FCurrencySwap', 'FCap', 'FFloor'):
        return payFrequencyIRS(ins)
    elif acmClass(ins) == 'FOption':
        und = get_underlying(ins)
        if acmClass(und) == 'FSwap':
            return payFrequencyIRS(und)

def APT_Universe_27_ShortPaymentFrequency(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FCreditDefaultSwap':
        return 
    elif acmClass(ins) in ('FSwap', 'FFrn', 'FCurrencySwap', 'FCap', 'FFloor'):
        return receiveFrequencyIRS(ins)
    elif acmClass(ins) == 'FOption':
        und = get_underlying(ins)
        if acmClass(und) == 'FSwap':
            return receiveFrequencyIRS(und)

def APT_Universe_28_Coupon(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) in ('FBond', 'FAssetMortgageBackedSecurity'):
        return ins.Legs().First().FixedRate()/100
    elif acmClass(ins) in ('FCap', 'FFloor'):
        return ins.StrikePrice()/100
    elif acmClass(ins) in ('FFreeDefinedCashFlow'):
        for l in ins.Legs():
            if l.LegType() == 'Fixed':
                return l.FixedRate()/100
        return 0.0

def APT_Universe_29_FloatingSpread(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FCreditDefaultSwap':
        try:
            fixedLeg = [leg for leg in ins.Legs() if leg.LegType() == 'Fixed'][0]
            return fixedLeg.FixedRate()*0.01
        except IndexError:
            return 0.0
    elif acmClass(ins) in ('FFrn', 'FCap', 'FFloor'):
        try:
            return [leg.Spread()/100 for leg in ins.Legs()][0]
        except IndexError:
            return 0
    elif acmClass(ins) in ('FFreeDefinedCashFlow'):
        for l in ins.Legs():
            if l.LegType() in ('Float', 'Capped Float', 'Cap', 'Floored Float', 'Floor', 'Collared Float'):
                return l.Spread()/100
        return 0.0
            
def APT_Universe_30_SwapRate(ins):
    """Autogenerated for portfoliosheet. """
    if acmClass(ins) == 'FSwap':
        try:
            fixedLeg = [leg for leg in ins.Legs() if leg.LegType() == 'Fixed'][0]
            return fixedLeg.FixedRate()*0.01
        except IndexError:
            return 0.0
    elif acmClass(ins) == 'FOption':
        und = get_underlying(ins)
        if acmClass(und) == 'FSwap': 
            return APT_Universe_30_SwapRate(und)

def APT_Universe_31_InflationIndex(rowObject):
    """Autogenerated for portfoliosheet. """
    return 

def APT_Universe_32_EffectiveDuration(rowObject):
    """Autogenerated for portfoliosheet. """
    return 

def APT_Universe_33_ServiceFee(rowObject):
    if rowObject.InsType() in ('MBS/ABS'):
        try:
            service_fee = rowObject.AdditionalInfo().APT_Service_Fee()
            return 0.0 if service_fee is None else service_fee
        except AttributeError:
            return 0.0
    return 

def APT_Universe_34_MBSType(rowObject):
    if rowObject.InsType() in ('MBS/ABS'):
        try:
            mbs_type = rowObject.AdditionalInfo().APT_MBS_Type()
            return 'GNMA1' if mbs_type is None else mbs_type
        except AttributeError:
            return 'GNMA1'
    return 

def APT_Universe_35_TermLength(ins):
    """Autogenerated for portfoliosheet. """
    und = get_underlying(ins)
    if acmClass(ins) == 'FFuture' and acmClass(und) in ('FRateIndex', 'FBill', 'FDeposit'):
        try:
            return TERM_MAP_IRF[und.Legs().First().EndPeriod()]
        except KeyError:
            return 'ONE_YEAR'

def APT_Universe_36_SwapType(ins):
    """Autogenerated for portfoliosheet. """
    und = ins.Underlying()
    if acmClass(ins) == 'FOption'and acmClass(und) == 'FSwap':
        undPayLegType = und.PayLeg().LegType()
        if undPayLegType == 'Fixed': return 'PAY_FIXED'
        elif undPayLegType == 'Float': return 'PAY_FLOATING'

def APT_Universe_37_SwapTermYrs(ins):
    """Autogenerated for portfoliosheet. """
    und = ins.Underlying()
    if acmClass(ins) == 'FOption'and acmClass(und) == 'FSwap':
        try:
            fixedLeg = [leg for leg in und.Legs() if leg.LegType() == 'Fixed'][0]
            return termMappingSwap(fixedLeg.RollingPeriod(), fixedLeg.DayCountMethod())
        except IndexError:
            return
            
def APT_Universe_38_UnderlyingType(rowObject):
    if rowObject.InsType() == 'CreditDefaultSwap':
        #UnderlyingType returns None on a cds
        return rowObject.Underlying().InsType() 
    else:
        return rowObject.UnderlyingType()


def APT_Universe_39_IsBarrier(ins):
    try:
        if ins.IsBarrier(): return 'True' 
        else: return 'False'
    except AttributeError:
        return
        
def APT_Universe_40_BarrierType(ins):
    try:
        type = ins.Exotic().BarrierOptionType().split('&')[1].upper()
        return type.strip()
    except (AttributeError, IndexError):
        return

def APT_Universe_41_BarrierDirection(ins):
    try:
        type = ins.Exotic().BarrierOptionType().split('&')[0].upper()
        return type.strip()
    except (AttributeError, IndexError):
        return


def APT_Universe_42_BarrierValue(ins):
    try:
        return ins.Barrier()
    except AttributeError:
        return
        

def APT_Universe_43_IsDigital(ins):
    try:
        if ins.Digital(): return 'True' 
        else: return 'False'
    except AttributeError:
        return


def APT_Universe_44_DigitalPayOff(ins):
    try:
        if ins.SettlementType() == "Cash": return "CASH"
        else: return "ASSET"
    except AttributeError:
        return

def APT_Universe_45_DigitalCashAmount(ins):
    try:
        return ins.Rebate()
    except AttributeError:
        return
        
def APT_Universe_46_CallCurrency(ins):
    try:
        if acmClass(ins) == 'FOption' and ins.UnderlyingType() == 'Curr':
            return ins.StrikeCurrency().Name()
    except AttributeError:
        return
        
def APT_Universe_47_PutCurrency(ins):
    try:
        if acmClass(ins) == 'FOption' and ins.UnderlyingType() == 'Curr':
            return ins.Underlying().Name()
    except AttributeError:
        return

def APT_Universe_48_RecoveryRate(rowObject):
    return

def apt_option_type(ins, apt_export_type):
    if not apt_export_type or apt_export_type in ('DELTA APPROX'):
        return 'Derivative'
    elif ins.UnderlyingType() in ('Stock', 'EquityIndex', 'Curr', 'Future/Forward', 'Swap'):
        if ins.IsDoubleBarrier():
            return 'Derivative'
        elif not ins.IsExotic() or ins.Digital() or ins.IsBarrier():
            if ins.UnderlyingType() in ('Curr') and ins.ExerciseType() not in ('European'):
                return 'Derivative'
            elif ins.ExerciseType() not in ('American', 'European'):
                return 'Derivative'
            return 'Option'
    return 'Derivative'

def APT_Universe_49_InsType(ins, apt_export_type):
    try:
        instype = ins.InsType()
        if instype == 'Future/Forward':
            if ins.PayType() == 'Future': return 'Future'
            else: return 'Forward'
        elif instype == 'Option':
            return apt_option_type(ins, apt_export_type)
        elif instype in ('VarianceSwap', 'VolatilitySwap'):
            return 'Derivative'
        return instype
    except AttributeError:
        return

def APT_Universe_51_IsCallable(ins):
    if ins.InsType() in ('Bond', 'FreeDefCF'):
        return 'True' if ins.Callable() else 'False'
    elif ins.InsType() == 'Convertible':
        try:
            import FMonisValuationUtils
            comObject = FMonisValuationUtils.get_FCOM_instrument(ins)
            return 'True' if comObject.CallsActive() else 'False'
        except:
            return
    return 'False'
        
def APT_Universe_52_CallSchedule(ins):
    if ins.InsType() in ('Bond', 'FreeDefCF'):
        if ins.Callable():
            call_schedule = ''
            for i in ins.ExerciseEvents():
                call_schedule += i.Date() + ',' + str(i.Strike()/100.0) + ';'
            return call_schedule[:len(call_schedule)-1]
    elif ins.InsType() == 'Convertible':
        try:
            import FMonisValuationUtils
            comObject = FMonisValuationUtils.get_FCOM_instrument(ins)
            isCallable = comObject.CallsActive()
            if isCallable:
                call_schedule = ''
                genericObject = comObject.GenericObject()
                numCallLevels = comObject.NumCallLevels()
                for index in range(numCallLevels):
                    value = genericObject.PerformWith('GetInputDouble',['CallLevels:%s:Value' % index ])
                    date = genericObject.PerformWith('GetInputDate',['CallLevels:%s:Date' % index ])
                    call_schedule += date[:10] + ',' + str(value/100.0) + ';'
                return call_schedule[:len(call_schedule)-1]
        except:
            return

def APT_Universe_54_PutAmount(rowObject):
    pass
      
def APT_Universe_55_UndRiskFreeRate(rowObject):
    """Autogenerated for portfoliosheet. """
    return 

       
def APT_Universe_56_ConversionStart(conv_start):
    try:
        return str(conv_start)[:10]
    except:
        return
    
def APT_Universe_57_ConversionEnd(conv_end):
    try:
        return str(conv_end)[:10]
    except:
        return
    
def APT_Universe_58_ConversionPrice(rowObject):
    try:
        import FMonisValuationUtils
        comObject = FMonisValuationUtils.get_FCOM_instrument(rowObject)
        comObject.ConvertConversionValuesAs('Price', 'Could not convert to Price')
        conversionPrice = comObject.InitialConvValue()
        return conversionPrice if conversionPrice else 0
    except:
        return 0

            
def APT_Universe_59_ForceConversion(force_conv):
    if force_conv == 'Yes': return 'true'
    else: return 'false'

def APT_Universe_60_IsStockTrigger(ins):
    if ins.InsType() == 'Convertible':
        try:
            import FMonisValuationUtils
            comObject = FMonisValuationUtils.get_FCOM_instrument(ins)
            isCallable = comObject.CallsActive()
            triggerSchedule = comObject.TriggerType()
            if isCallable and triggerSchedule:
                return 'True'
            return 'False'
        except:
            return 'False'
    return 'False'
    
def APT_Universe_61_UndAssetClass(ins):
    und = get_underlying(ins)
    if und:
        return apt_asset_class(und)
        
def APT_Universe_62_CurrencyIdType(rowObject):
    return 'ISIN'

def APT_Universe_63_UnderlyingClass(rowObject):
    und = get_underlying(rowObject)
    if und:
        return apt_asset_class(und)
    return
    
def APT_Universe_64_StockTriggerSchedule(ins):
    if ins.InsType() == 'Convertible':
        try:
            import FMonisValuationUtils
            comObject = FMonisValuationUtils.get_FCOM_instrument(ins)
            isCallable = comObject.CallsActive()
            triggerSchedule = comObject.TriggerType()
            if isCallable and triggerSchedule != None:
                trigger_schedule = ''
                genericObject = comObject.GenericObject()
                numTriggerLevels = comObject.NumTriggerLevels()
                for index in range(numTriggerLevels):
                    value = genericObject.PerformWith('GetInputDouble',['TriggerLevels:%s:Value' % index ])
                    date = genericObject.PerformWith('GetInputDate',['TriggerLevels:%s:Date' % index ])
                    trigger_schedule += date[:10] + ',' + str(value/100) + ';'
                return trigger_schedule[:len(trigger_schedule)-1]
        except:
            return ''
            
def _timeseries_message(ins):
    MESSAGE = "The number of weekly returns from the models date is %i. APT needs at least 22 weekly data points not to set all component loadings to 0 and the residual risk to the measured volatility"
    used_model_date = FAptTest.AptTest.get_used_model_date()
    timeSeries = FAptReportCommon.AptTimeSeries(ins.Name())
    dates = timeSeries.get_weekly_dates()
    data_points = len([date for date in dates.split() if re.sub('-', '', date) <= used_model_date])
    if data_points < 22:
        MESSAGE = "WARNING! %s" % (MESSAGE % data_points)
    else:
        MESSAGE = "GOOD! %s" % (MESSAGE % data_points)
    return MESSAGE

def _credit_message(ins):
    creditRef = ins
    borrowerClass = APT_Universe_19_BorrowerClass(creditRef, creditRef.Issuer())
    try:
        borrowerClass = borrowerClass.Name()
    except AttributeError:
        pass 
    rating = APT_Universe_20_CreditRating(creditRef)
    try:
        rating = rating.Name()
    except AttributeError:
        pass 
    MESSAGE = "Borrower Classification set to %s. Rating set to %s. Please, ensure that these values are correct to have a more accurate credit exposure on APT" % (borrowerClass, rating)
    return MESSAGE

def APT_Universe_65_IdReconMessages(ins):
    insType = ins.InsType()
    aptid_type = ins.AdditionalInfo().APT_Recon_Id_Type()
    if aptid_type == 'OTC':
        if insType in ('Stock', 'EquityIndex'):
            return _timeseries_message(ins)
        elif insType in ('Bond', 'Convertible'):
            return _credit_message(ins)
            
def APT_Universe_66_LongLegPrincipal(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    return ins.NominalAmount()*receiveLeg.NominalFactor()

def APT_Universe_67_ShortLegPrincipal(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    return ins.NominalAmount()*payLeg.NominalFactor()
    
def APT_Universe_68_LongLegCurrency(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    return receiveLeg.Currency()
    
def APT_Universe_69_ShortLegCurrency(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    return payLeg.Currency()
    
def APT_Universe_70_ShortLegIsFixed(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    return payLeg.LegType() in ('Fixed')

def APT_Universe_71_LongLegIsFixed(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    return receiveLeg.LegType() in ('Fixed')

def APT_Universe_72_FixedLongLegDate(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    if receiveLeg.LegType() in ('Fixed'):
        return receiveLeg.StartDate()

def APT_Universe_73_FloatLongLegDate(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    if receiveLeg.LegType() in ('Float'):
        return receiveLeg.StartDate()

def APT_Universe_74_FixedLongLegCoupon(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    if receiveLeg.LegType() in ('Fixed'):
        return receiveLeg.FixedRate()/100

def APT_Universe_75_FloatLongLegSpread(ins):
    receiveLeg = [leg for leg in ins.Legs() if not leg.PayLeg()][0]
    if receiveLeg.LegType() in ('Float'):
        spread = receiveLeg.Spread()
        return spread if spread else 0.001

def APT_Universe_76_FixedShortLegDate(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    if payLeg.LegType() in ('Fixed'):
        return payLeg.StartDate()

def APT_Universe_77_FloatShortLegDate(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    if payLeg.LegType() in ('Float'):
        return payLeg.StartDate()

def APT_Universe_78_FixedShortLegCoupon(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    if payLeg.LegType() in ('Fixed'):
        return payLeg.FixedRate()/100

def APT_Universe_79_FloatShortLegSpread(ins):
    payLeg = [leg for leg in ins.Legs() if leg.PayLeg()][0]
    if payLeg.LegType() in ('Float'):
        spread = payLeg.Spread()
        return spread if spread else 0.001
        
def APT_Universe_82_IsForwardStart(object):
    cls = acmClass(object)
    if cls in ('FSwap', 'FCurrencySwap'):
        startDate = object.StartDate()
        return startDate > acm.Time.DateValueDay()
    return False
    
def APT_Universe_83_InstrumentStartDate(object):
    return object.StartDate()

def APT_Compositions_84_DomesticCurrencyIdType(ins):
    curr = ins.DomesticCurrency()
    return apt_id_type(curr)
    
def APT_Compositions_85_ForeignCurrencyIdType(ins):
    curr = ins.ForeignCurrency()
    return apt_id_type(curr)

def APT_Universe_93_Cap(ins):
    legs = [leg for leg in ins.Legs() if leg.LegType() in ('Capped Float', 'Cap', 'Collared Float')]
    try:
        return legs[0].Strike()
    except:
        return 0.0

def APT_Universe_94_Floor(ins):
    legs = [leg for leg in ins.Legs() if leg.LegType() in ('Floored Float', 'Floor', 'Collared Float')]
    try:
        return legs[0].Strike2()
    except:
        return 0.0

def APT_Universe_95_FirstFloatLegType(ins):
    legs = [leg for leg in ins.Legs() if leg.LegType() in ('Float', 'Capped Float', 'Cap', 'Floored Float', 'Floor', 'Collared Float')]
    try:
        return legs[0].LegType()
    except:
        return 0.0

def APT_Universe_96_FirstFloatLegDate(ins):
    legs = [leg for leg in ins.Legs() if leg.LegType() in ('Float', 'Capped Float', 'Cap', 'Floored Float', 'Floor', 'Collared Float')]
    try:
        return legs[0].StartDate()
    except:
        return 0.0

def APT_Universe_97_FirstFixedLegDate(ins):
    legs = [leg for leg in ins.Legs() if leg.LegType() in ('Fixed')]
    try:
        return legs[0].StartDate()
    except:
        return 0.0

def set_addinfo(obj, fieldVec, valueVec):
    for i in range(len(fieldVec)):

        field = fieldVec[i]
        value = valueVec[i]
        addSpec = acm.FAdditionalInfoSpec[field]
        a = addSpec.AddInfoContainer(obj)
        if a.Size() > 0:             
            a.At(0).FieldValue = str(value)
            a.Commit()    
        elif value:
            ai = acm.FAdditionalInfo()
            ai.AddInf(addSpec)
            ai.FieldValue = str(value)            
            ai.Recaddr = obj.Oid()
            ai.Commit()    	


def onIdTypeSave(eii):
    cells = eii.ExtensionObject().ActiveSheet().Selection().SelectedCells()
    for cell in cells:
        column = cell.Column()
        columnId = column.ColumnId()
        if str(columnId) == "APT_Compositions_00_AptReconIdType":
            row = cell.RowObject()
            instrument = row.Instrument()
            apt_id_recon_eval = cell.Evaluator()
            apt_id_recon_value = apt_id_recon_eval.Value()
            try:
                set_addinfo(instrument, ['APT Recon Id Type'], [apt_id_recon_value])
                apt_id_recon_eval.RemoveSimulation()
            except Exception as err:
                logger.error('Failed to save additional info value. Error: %s', err)
                
def get_exp_type_addinfo(ins, index):
    ins_type = ins.InsType()
    if ins_type in 'Option':
        return ['DELTA APPROX', 'CONTRACT PARAMS'][index]
    elif ins_type in 'CFD':
        return ['UNDERLYING', 'SYNTH APPROX'][index]
    else:
        return ['CONTRACT PARAMS'][index]

                
def onExportTypeSave(eii):
    cells = eii.ExtensionObject().ActiveSheet().Selection().SelectedCells()
    for cell in cells:
        column = cell.Column()
        columnId = column.ColumnId()
        if str(columnId) == "APT_Compositions_19_AptExportType":
            row = cell.RowObject()
            ins = row.Instrument()
            apt_export_type_eval = cell.Evaluator()
            apt_export_type_value = apt_export_type_eval.Value()
            apt_exp_type_addinfo = get_exp_type_addinfo(ins, apt_export_type_value)
            try:
                set_addinfo(ins, ['APT Export Type'], [apt_exp_type_addinfo])
                apt_export_type_eval.RemoveSimulation()
            except Exception as err:
                logger.error('Failed to save additional info value. Error: %s', err)

            


