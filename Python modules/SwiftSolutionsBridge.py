"""SwiftSolutionsBridge - Extension for the SwiftSolutions deployment to allow backwards compatibility
                          to read incomming SWIFT messages from Meridian. Direct replacement for G1/Airflow process.

Configs:
    FSwiftSolutionBridgeConfig
        AMBAddress - AMB to post the incomming messages to.

    FSwiftReaderConfig
        AMBReceiverSubject - AMB Subject for messages

    FSwiftSolutionBridgeConfig
        MeridianPickupPath - The G1/Airflow folder path where Meridian drops its messages.
        ArchivePath - The path where this script will archive messages to after processing.
        AMBSenderName - AMB sender name.

Dependancies:
    The correct Meridian FTP location needs to be mounted at the path specified in FSwiftSolutionBridgeConfig.

Pre-SwiftSolutions:
    Outgoing:
        Once settlements get released, SWIFT messages would be generated through Global 1/Adaptiv
        and dropped into a network folder. Airflow would then move the messages from this location
        to Meridian to be processed.

    Incomming:
        Airflow would read incomming messages.

Post-SwiftSolutions:
    Outgoing:
        Once settlements get released, SWIFT messages are generated by FSwiftSolutions, and the file 
        is dropped into the path specified through parameters (directly into Meridians outgoing folder).
        This also keeps the message format the same as it was when using the previous process, so no changes
        required from Meridan.

    Incomming:
        A task is scheduled to run SwiftSolutionsBridge. The module will read all the messages from 
        the path specified in the parameters (directly from Meridan) to process AckNack/Incomming SWIFT
        messages.
        
        The path points to the Archive location on Meridian, this was done due to race conditions where 
        other processes are reading the same files from the existing location. We instead wait for the
        existing processes to finish, then pick the file up to reduce any downstream impact.

        A bash command is run from python to find the subset of files within the archive folder. Since there
        could potentially be thousands of files in the folder, the native unix find is used with a set date from
        which to process incomming messages through swift solutions (This should be the go live date).

History
=======
2020-04-28 Faize Adams    features/Swift-Solutions    Initial deployment with main Swift Solutions.

"""
from os import listdir, path
from os.path import isfile, join
import subprocess
import shutil
import time
import at_logging
import FSwiftMLUtils
import FSwiftOperationsAPI
import amb
import acm
import re
import FSwiftMLUtils
import FSwiftWriterUtils
import json

ENVIRONMENTCONFIG = FSwiftWriterUtils.get_config_from_fparameter('FSwiftSolutionConfig')
SWIFTREADERCONFIG = FSwiftWriterUtils.get_config_from_fparameter('FSwiftReaderConfig')
SWIFTSOLUTIONSBRIDGECONFIG = FSwiftWriterUtils.get_config_from_fparameter('FSwiftSolutionBridgeConfig')

MERIDIANPICKUPLOCATION = json.loads(SWIFTSOLUTIONSBRIDGECONFIG.MeridianPickupPath)
ARCHIVELOCATION = SWIFTSOLUTIONSBRIDGECONFIG.ArchivePath
AMBSENDERNAME = SWIFTSOLUTIONSBRIDGECONFIG.AMBSenderName

AMBHOST = ENVIRONMENTCONFIG.AMBAddress
AMBSUBJECT = SWIFTREADERCONFIG.AMBReceiverSubject

FINDSWIFTFILESBASHCOMMAND = ["find", "-maxdepth", "1", "-type", "f", "-newermt", "6/11/2020 16:30:00", "-name", "G1*"]
FINDSWIFTFILESBASHCOMMAND[1:1] = MERIDIANPICKUPLOCATION

LOGGER = at_logging.getLogger()

ael_variables = []

def getSortedListOfSwifts(swiftMessageData):
    swiftMessageList = re.findall('{1:.*?}.*?{5:.*?}}', swiftMessageData, flags=re.S)
    print "sorting %s swifts" % len(swiftMessageList)
    messageDictionary = {}
    for message in swiftMessageList:
        prepTag = re.findall('{1:(F01ABSA.*?)}', message, flags=re.S)[0]
        messageDictionary[prepTag] = message
    return sorted(messageDictionary.keys()), messageDictionary


def MeridiaSwiftToFA():
    LOGGER.info("Read Swift messages from Meridian drop location and put on FA AMB")
    lineCounter = 0
    processedMessages = []
    
    try:
        processFindFiles = subprocess.Popen(FINDSWIFTFILESBASHCOMMAND, stdout=subprocess.PIPE)
        filesFound, error = processFindFiles.communicate()
        swiftFilesList = filesFound.split("\n")
        swiftsToPost = [file for file in swiftFilesList if isfile(file) and 'G1' in file]
        
        if not swiftsToPost:
            LOGGER.info("No messages to post")
        else:            
            LOGGER.info("Posting %s messages to FA AMB %s" % (len(swiftsToPost), MERIDIANPICKUPLOCATION))
            for swift in swiftsToPost:
                LOGGER.info("%s. Posting %s" % (lineCounter, swift))
                try:
                    if path.basename(swift) not in processedMessages:
                        with open(swift, 'r') as file:
                            swiftMessageData = file.read()
                            if 'G1Incoming' in swift:
                                orderOfIncomingSwifts, swiftDict = getSortedListOfSwifts(swiftMessageData)
                                for swiftKey in orderOfIncomingSwifts:
                                    swiftMessage = swiftDict[swiftKey]
                                    writeToAMB(swiftMessage)
                                    lineCounter += 1
                            elif 'G1AckNack' in swift:
                                ackNackSettlementNumbers = []
                                if swiftMessageData.__contains__('}{2:I598'):  
                                    ackNackSettlementNumbers.extend(re.findall(':26H:[A-Z]{1,2}[0-9]{1,6}?\/([0-9]{1,10})', swiftMessageData, flags=re.S))

                                if swiftMessageData.__contains__('}{2:I54'):  
                                    ackNackSettlementNumbers.extend(re.findall(':20C::SEME//FAS-([0-9]{1,10})', swiftMessageData, flags=re.S))
                                
                                for settlementNumber in ackNackSettlementNumbers:
                                    try:
                                        settlement = acm.FSettlement[settlementNumber]
                                        settlementSI = settlement.StorageImage()
                                        settlementSI.Status('Acknowledged')
                                        settlementSI.Commit()
                                        LOGGER.info( 'Acknowledged %s' % settlementNumber)
                                    except Exception, e:
                                        LOGGER.info('Exception updating settlement %s to Acknowledged: %s' % (settlementNumber, str(e)))
                                    
                            LOGGER.info("Moving %s to %s" % (swift, ARCHIVELOCATION))
                            shutil.move(swift, ARCHIVELOCATION)
                            processedMessages.append(path.basename(swift))
                            LOGGER.info("Moved files")
                except Exception, e:
                    LOGGER.info('Exception with file %s: %s' % (swift, str(e)))

            LOGGER.info("Done posting %s files. %s messages" % (len(swiftsToPost), lineCounter))
    except Exception as ex:
        print ex.args[-1]
        print "Some other exception: %s" % str(ex)


def eventCallback(channel, event, arg):
        pass


def CreateAMBAMessageFromString(string):
    messageBuffer = amb.mbf_create_buffer_from_data(string)
    messageObj = messageBuffer.mbf_read()
    ambaMessage = FSwiftOperationsAPI.AMBAMessage(messageObj)
    return ambaMessage


def writeToAMB(messageAsString):
    messageAsString = messageAsString.strip()
    amb.mb_init(AMBHOST)
    writer = amb.mb_queue_init_writer(AMBSENDERNAME, eventCallback, None)
     
    message = amb.mbf_start_message(None, AMBSUBJECT, "1.0", None, "SWIFT_NETWORK")
    mbMessage = message.mbf_start_list("SWIFT_MESSAGE")
    mbMessage.mbf_add_string("SWIFT", messageAsString)
    mbMessage.mbf_end_list()
    message.mbf_end_message()
    buffer = amb.mbf_create_buffer()
    message.mbf_generate(buffer)

    status = amb.mb_queue_write(writer, AMBSUBJECT, buffer.mbf_get_buffer_data(), buffer.mbf_get_buffer_data_size(), time.strftime("%Y-%m-%d %H:%M:%S"))

    lastMid = amb.mb_last_write_message_id(writer)
    
    print "Message %s successfully written to AMB %s" % (lastMid, AMBHOST) 

def ael_main(aelDict):
    MeridiaSwiftToFA()
