"""-----------------------------------------------------------------------------
MODULE	    	FDigitalCDS 

(c) Copyright 2000 by Front Capital Systems AB. All rights reserved.

Version: 1.4

DESCRIPTION
    This module values digital credit default swaps and ordinary credit
    default swaps.
ENDDESCRIPTION
-----------------------------------------------------------------------------"""
import ael

"""-----------------------------------------------------------------------------
FUNCTION    Theor
DESCRIPTION
    This function calles the valuation function with the right parameters.
ARGUMENTS
    o = ael entity.
    calc = Flag to indicate that a calculation of payment is expected. 0 or 1.
    ref = Reference to a payment description generated by the function on a
    previous call. This reference indicates which payments that do need to be
    recalculated.
RETURNS
    all payments to the core system. 
-----------------------------------------------------------------------------"""
def Theor(o, calc, ref):
    payments=[]
    if o.record_type == 'CashFlow':
    	theor_cf(o, calc, ref, payments)
	return payments
    if o.record_type == 'Leg':
    	for c in o.cash_flows():
            theor_cf(c, calc, ref, payments)
	return payments
    for j in o.legs():
    	for c in j.cash_flows():
            theor_cf(c, calc, ref, payments)
    return payments

"""-----------------------------------------------------------------------------
FUNCTION    Prob
DESCRIPTION
    This function calculates the probability for the default event
ARGUMENTS
    o = ael entity
    nrofstep = float number, the number of steps to take in the tree.
    RecRate = float number, the recovery rate
RETURNS
    a vector of probabilities and a vector with the riskfree rate.
-----------------------------------------------------------------------------"""
def Prob(c, nrofstep, RecRate):
    prob=[]
    riskfree=[]
    today=ael.date_valueday()
    start=date=c.start_day
    end=c.end_day
    dt=int(date.days_between(end)/nrofstep)
    if dt < 1:
    	dt=1
    ycry=c.legnbr.credit_ref.used_yield_curve(c.legnbr.curr)
    ycrf=c.legnbr.insaddr.used_yield_curve(c.legnbr.curr)
    while (date < end):
	date2=date.add_days(dt)
	if date2 < end:
    	    DiscRisky = ycry.yc_rate(date, date2, 'Continuous', 'Act/360',\
	    	    'Discount', 0)
    	    DiscRiskfree = ycrf.yc_rate(date, date2, 'Continuous', 'Act/360',\
	    	    'Discount', 0,)
	    if RecRate == 100:
	    	prob.append(0.0)
	    else:
		prob.append((1.0-DiscRisky/DiscRiskfree)/(1-RecRate/100.0))
	    riskfree.append(ycrf.yc_rate(today, date2, 'Continuous', 'Act/360',\
	    	    'Discount', 0,))
	else:
    	    DiscRisky = ycry.yc_rate(date, end, 'Continuous', 'Act/360',\
	    	    'Discount', 0)
    	    DiscRiskfree = ycrf.yc_rate(date, end, 'Continuous', 'Act/360',\
	    	    'Discount', 0,)
    	    if RecRate == 100:
	    	prob.append(0.0)
	    else:
		prob.append((1.0-DiscRisky/DiscRiskfree)/(1-RecRate/100.0))
	    riskfree.append(ycrf.yc_rate(today, end, 'Continuous', 'Act/360',\
	    	    'Discount', 0,))
	date=date2
    return prob, riskfree
    
"""-----------------------------------------------------------------------------
FUNCTION    theor_cf
DESCRIPTION
    Calculates the theoretical value of the cashflows for the credit default swap.
ARGUMENTS
    c = ael entity cashflow
    calc = Flag to indicate that a calculation of payment is expected. 0 or 1.
    ref = Reference to a payment description generated by the function on a
    previous call. This reference indicates which payments that do need to be
    recalculated.
    payments = a vector containing vectors with all the data about all the
    projected cashflows in the instrument.
    nrofstep = float number, the number of steps to take in the tree.
RETURNS 
    the payment of the cashflow
-----------------------------------------------------------------------------"""
def theor_cf(c, calc, ref, payments):
    if ref == None or c == ref:
    	res = 0.0
	if calc:
	    RecRate=0.0
	    for l in c.legnbr.insaddr.legs():
		if l.type == 'Credit Default':
		    RecRate=float(l.credit_ref.issuer_ptynbr.add_info('RecoveryRate'))
		    if (RecRate >= 100 or RecRate < 0):
			RecRate=0.0
			print 'Recovery Rate value is unrealistic'
	    if c.type == 'Credit Default':
    	    	date=ael.date_valueday()
    	    	start=c.start_day
		end=c.end_day
    	    	nrofstep=start.periods_between(end, '1m')
		if nrofstep <= 0:
	    	    res=0.0
    	    	else:
		    if c.legnbr.insaddr.add_info('CDPayoutType') == 'ParMinusRecovery':
			payout=(1.0-RecRate/100.0)
		    elif c.legnbr.insaddr.add_info('CDPayoutType') == 'Digital':
			PercentPayout=float(c.legnbr.insaddr.add_info('CDPercentPayout'))
			if (PercentPayout > 0.0): 
			    payout=PercentPayout/100.0
			else:
			    print 'CDPercentPayout value is unrealistic'
			    payout=0.0
		    else:
			print 'Unknown CD PayoutType method'
			payout=0.0
    		    prob, riskfree=Prob(c, nrofstep, RecRate)		
		    res=0.0
		    for i in range(0, len(prob)):
			res=res+(payout*prob[i]*riskfree[i]*\
		    		c.nominal_amount()/c.legnbr.insaddr.contr_size)
		    if c.legnbr.payleg:
		    	res=-1.0*res
		p=[res, c.pay_day, c.legnbr.curr, 'Float', c]
	    else:
		nominal=c.nominal_amount()/c.legnbr.insaddr.contr_size
		if c.type == 'Fixed Amount':
		    res=nominal
		else:
		    rate=c.period_rate()
    	    	    period=c.start_day.years_between(c.end_day, c.legnbr.daycount_method)
		    res=rate/100.0*nominal*period
		ycry=c.legnbr.credit_ref.used_yield_curve(c.legnbr.curr)
    		ycrf=c.legnbr.insaddr.used_yield_curve(c.legnbr.curr)
		DiscRisky=ycry.yc_rate(ael.date_valueday(), c.pay_day, 'Continuous', 'Act/365', 'Discount')
		DiscRiskfree=ycrf.yc_rate(ael.date_valueday(), c.pay_day, 'Continuous', 'Act/365', 'Discount')
    		disc=1-((1-DiscRisky/DiscRiskfree)/(1-RecRate/100))
		if c.pay_day <= ael.date_today():
		    res=res
		else:
		    res=disc*DiscRiskfree*res
	    	if c.legnbr.payleg:
    		    res=-1.0*res
		p=[res, c.pay_day, c.legnbr.curr, 'Fixed', c]
		
	    payments.append(p)
    	else:
    	    if c.type == 'Credit Default':
	    	p=[res, c.pay_day, c.legnbr.curr, 'Float', c]
    	    else:
	    	p=[res, c.pay_day, c.legnbr.curr, 'Fixed', c]
	    payments.append(p)

